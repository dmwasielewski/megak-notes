<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MegaKurs - JavaScript</title>
    <link href="https://fonts.googleapis.com/css?family=Roboto:400,700&display=swap&subset=latin-ext"
        rel="stylesheet" />
    <link rel="stylesheet" href="../normalize.css" />
    <link rel="stylesheet" href="../style.css" />
    <script src="https://kit.fontawesome.com/9e22ac749d.js" crossorigin="anonymous"></script>
</head>

<body>
    <header class="header">
        <nav class="header-navigation">
            <nav class="hamburger-menu hamburger-menu--js">
                <ul class="hamburger-menu__list">
                    <li class="hamburger-menu__list-item">
                        <a class="hamburger-menu__link" href="../index.html">strona główna</a>
                    </li>
                    <li class="hamburger-menu__list-item">
                        <a class="hamburger-menu__link" href="#">1: JavaScript</a>
                    </li>
                    <li class="hamburger-menu__list-item">
                        <a class="hamburger-menu__link" href="#">2: Node.js</a>
                    </li>
                    <li class="hamburger-menu__list-item">
                        <a class="hamburger-menu__link" href="#">3: Express.js</a>
                    </li>
                    <li class="hamburger-menu__list-item">
                        <a class="hamburger-menu__link" href="#">4: bazy danych</a>
                    </li>
                    <li class="hamburger-menu__list-item">
                        <a class="hamburger-menu__link" href="#">5: TypeScript</a>
                    </li>
                    <li class="hamburger-menu__list-item">
                        <a class="hamburger-menu__link" href="#">6: Full-stack developer</a>
                    </li>
                    <li class="hamburger-menu__list-item">
                        <a class="hamburger-menu__link" href="#">7: Node.js advanced</a>
                    </li>
                </ul>
            </nav>
            <button class="header-navigation__menu-button">
                <i class="fas fa-bars"></i>
            </button>
            <p class="header-navigation__text">mega kurs javascriptu</p>
        </nav>
    </header>
    <main id="top" class="theory-main">
        <h1 class="theory-main__heading">javascript</h1>
        <nav class="theory-main__links">
            <a href="#fundaments" class="theory-main__link">fundamenty javascriptu</a>
            <span class="theory-main__text">•</span>
            <a href="#operations" class="theory-main__link">operacje i operatory</a>
            <span class="theory-main__text">•</span>
            <a href="#variables" class="theory-main__link">zmienne</a>
            <span class="theory-main__text">•</span>
            <a href="#arrays" class="theory-main__link">tablice</a>
            <span class="theory-main__text">•</span>
            <a href="#loops" class="theory-main__link">pętle</a>
            <span class="theory-main__text">•</span>
            <a href="#conditional-statements" class="theory-main__link">instrukcje warunkowe</a>
            <span class="theory-main__text">•</span>
            <a href="#data-types" class="theory-main__link">typy danych</a>
            <span class="theory-main__text">•</span>
            <a href="#functions" class="theory-main__link">funkcje</a>
            <span class="theory-main__text">•</span>
            <a href="#object-orientation" class="theory-main__link">obiektowość</a>
            <span class="theory-main__text">•</span>
            <a href="#ecmascript-6" class="theory-main__link">ecmascript 6</a>
            <span class="theory-main__text">•</span>
            <a href="#classes" class="theory-main__link">klasy</a>
            <span class="theory-main__text">•</span>
            <a href="#advanced-arrays" class="theory-main__link">zaawansowane metody tablicowe</a>
            <span class="theory-main__text">•</span>
            <a href="#asynchrony" class="theory-main__link">asynchroniczność</a>
            <span class="theory-main__text">•</span>
            <a href="#dom" class="theory-main__link">dom</a>
            <span class="theory-main__text">•</span>
            <a href="#local-storage" class="theory-main__link">local storage</a>
            <span class="theory-main__text">•</span>
            <a href="#json" class="theory-main__link">json</a>
        </nav>
        <div class="theory-main__image"></div>
        <article id="fundaments" class="article">
            <h2 class="article__heading">fundamenty javascriptu</h2>
            <p class="article__text">Cechy JavaScript:</p>
            <ul class="article__list">
                <li class="article__list-item">
                    <strong>Język wysokiego poziomu</strong> - wiele rzeczy dziejących się na niższym
                    poziomie wykonuje się automatycznie, z dala od kodu maszynowego.
                </li>
                <li class="article__list-item">
                    <strong>Słabo typowany</strong> - brak konieczności wskazywania typów zmiennych
                    podczas deklaracji, typ zostanie nadany automatycznie przez
                    JavaScript.
                </li>
                <li class="article__list-item">
                    <strong>Dynamicznie typowany</strong> - podczas działania programu do konkretnej
                    zmiennej może zostać przypisany inny typ danych.
                </li>
                <li class="article__list-item">
                    <strong>Język interpretowany</strong> - odczytywany linijka po linijce przez
                    przeglądarkę i przekształcany na kod maszynowy w czasie działania
                    programu, lecz ze względu na zwiększenie szybkości działania może
                    być również kompilowany (zamieniony przed uruchomieniem programu na kod maszynowy rozumiany przez
                    komputer). Możliwa jest także opcja łącząca obie metody.
                </li>
            </ul>
            <p class="article__text">Niektóre typy danych:</p>
            <ul class="article__list">
                <li class="article__list-item"><strong>string</strong> - tekst;</li>
                <li class="article__list-item"><strong>integer</strong> - liczba całkowita;</li>
                <li class="article__list-item"><strong>boolean</strong> - prawda lub fałsz.</li>
            </ul>
            <p class="article__text">Jak uruchomić JavaScript:</p>
            <ul class="article__list">
                <li class="article__list-item">Narzędzia w internecie (np. <a class="article__link"
                        href="https://codepen.io">codepen.io</a> (zalecany dla front-endu), <a class="article__link"
                        href="https://replit.com/">replit.com</a> (zalecany dla back-endu)).
                </li>
                <li class="article__list-item">Środowisko uruchomieniowe Node.js.</li>
                <li class="article__list-item">Przeglądarka internetowa.</li>
            </ul>
            <p class="article__text"><strong>Interpreterem</strong> JavaScript w przeglądarce (zarówno Chrome jak i
                Edge) jest stworzony
                przez Google <strong>silnik V8</strong>.
            </p>
            <p class="article__text"><strong>API</strong> - dodatkowe funkcjonalności (nie są częścią specyfikacji
                JavaScript)
                dostarczone przez Node.js lub przez przeglądarkę (mogą być różne dla obu środowisk).
                Przykład: console.log() nie jest częścią specyfikacji, lecz funkcjonalnością, która została dostarczona
                zarówno przez Node.js jak i przez przeglądarkę pod tą samą nazwą, w celu ułatwienia korzystania z obu
                środowisk.</p>
            <p class="article__text"><strong>window.prompt()</strong> - metoda pozwalająca na pobranie danych od
                użytkownika.</p>
        </article>
        <article id="operations" class="article">
            <h2 class="article__heading">operacje i operatory</h2>
            <p class="article__text">Operatory arytmetyczne:</p>
            <ul class="article__list">
                <li class="article__list-item"><strong>+</strong> - dodawanie;</li>
                <li class="article__list-item"><strong>-</strong> - odejmowanie;</li>
                <li class="article__list-item"><strong>/</strong> - dzielenie;</li>
                <li class="article__list-item"><strong>*</strong> - mnożenie;</li>
                <li class="article__list-item"><strong>**</strong> - potęgowanie;</li>
                <li class="article__list-item"><strong>Inkrementacja</strong> - zwiększenie wartości o 1;</li>
                <li class="article__list-item"><strong>Dnkrementacja</strong> - zmniejszenie wartości o 1.</li>
            </ul>
            <p class="article__text">Wyrażenia matematyczne wykonywane są zgodnie z zasadami wykonywania działań
                (możliwe jest użycie nawiasów). Podczas wykonywania takich wyrażeń zwracany jest ich wynik.</p>
            <a class="article__link" href=""></a>
            <p class="article__text">Operatory porównania:</p>
            <ul class="article__list">
                <li class="article__list-item"><strong>></strong> - większy;</li>
                <li class="article__list-item"><strong>>=</strong> - większy bądź równy;</li>
                <li class="article__list-item"><strong>&lt;</strong> - mniejszy;</li>
                <li class="article__list-item"><strong>&lt;=</strong> - mniejszy bądź równy);</li>
                <li class="article__list-item"><strong>==</strong> - równy (bez porównania typu zmiennej);</li>
                <li class="article__list-item"><strong>===</strong> - równy (z porównaniem typu zmiennej);</li>
                <li class="article__list-item"><strong>!=</strong> - różny (bez porównania typu zmiennej);</li>
                <li class="article__list-item"><strong>!==</strong> - różny (z porównaniem typu zmiennej).</li>
            </ul>
            <p class="article__text">Dobrą praktyką jest używanie <b>===</b> podczas wykonywania porównań. <a
                    class="article__link" href="https://dorey.github.io/JavaScript-Equality-Table/unified/">Tabela</a>
                obrazująca różnice w porównaniach z użyciem różnych operatorów równości.</p>
            <p class="article__text">Operatory logiczne:</p>
            <ul class="article__list">
                <li class="article__list-item"><strong>&&</strong> - wszystkie warunki muszą być
                    prawdziwe, żeby wyrażenie było prawdziwe (logiczne "i");</li>
                <li class="article__list-item">
                    <strong>||</strong> - przynajmniej jeden warunek musi być
                    prawdziwy, żeby wyrażenie było prawdziwe (logiczne "lub");
                </li>
                <li class="article__list-item"><strong>!</strong> - odwraca wartość wyrażenia logicznego (negacja).</li>
            </ul>
            <p class="article__text">Podwójna negacja (<b>!!</b>) pozwala na sprawdzenie jaką wartość logiczną przyjmie
                operand po konwersji do typu "boolean".</p>
            <p class="article__text">Operatory przypisania:</p>
            <ul class="article__list">
                <li class="article__list-item"><strong>=</strong> - przypisanie operandu z prawej strony operatora do
                    operandu z lewej strony operatora;</li>
                <li class="article__list-item"><strong>*=</strong> - nadpisanie operandu z lewej strony operatora przez
                    pomnożenie go przez operand z prawej strony operatora;</li>
                <li class="article__list-item"><strong>/=</strong> - nadpisanie operandu z lewej strony operatora przez
                    podzielenie go przez operand z prawej strony operatora;</li>
                <li class="article__list-item"><strong>%=</strong> - nadpisanie operandu z lewej strony operatora przez
                    resztę z dzielenia go przez operand z prawej strony operatora;</li>
                <li class="article__list-item"><strong>+=</strong> - nadpisanie operandu z lewej strony operatora przez
                    dodanie do niego operandu z prawej strony operatora;</li>
                <li class="article__list-item"><strong>-=</strong> - nadpisanie operandu z lewej strony operatora przez
                    odjęcie od niego operandu z prawej strony operatora.</li>
            </ul>
            <p class="article__text"><a class="article__link"
                    href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table">Tabela</a>
                pierwszeństwa
                operatorów.</p>
        </article>
        <article id="variables" class="article">
            <h2 class="article__heading">zmienne</h2>
            <p class="article__text"><strong>Zmienna</strong> - miejsce w pamięci, przechowujące pewne informacje.
                Precyzyjniej jest to połączenie między zadeklarowaną nazwą a miejscem w pamięci przechowującym pewną
                wartość. Wartość posiada typ, natomiast zmienna - nie. </p>
            <p class="article__text">Koncept <strong>immutability</strong> polega na tym, że nie można zmieniać
                wartości 'primitive
                values' (wartości typów prostych, do których podłączamy się za pomocą zmiennych) w JavaScript. To co
                zmieniamy, to połączenia między nimi a zmiennymi. Wartości już istnieją, są niezmienne. Na przykład nie
                można sobie zmienić 'true' na 'false' lub na odwrót.</p>
            <p class="article__text">
                Słowa kluczowe służące do deklaracji zmiennych w JavaScript (możliwa jest również deklaracja bez
                poprzedzenia nazwy zmiennej słowem kluczowym, lecz nie należy stosować takiej praktyki):
            </p>
            <ul class="article__list">
                <li class="article__list-item">
                    <strong>const</strong> Deklaruje zmienną. Połączenie między zmienną i jej
                    wartością nie może być zmieniane w trakcie działania programu.
                </li>
                <li class="article__list-item">
                    <strong>let</strong> Deklaruje zmienną. Połączenie między zmienną i jej
                    wartością może być zmieniane w trakcie działania programu.
                </li>
                <li class="article__list-item">
                    <strong>var</strong> Używany do deklaracji we wcześniejszych wersjach
                    JavaScriptu. Teraz do deklaracji zmiennych należy używać słowa
                    kluczowego <b>const</b>, a jeśli połączenie między zmienną i jej
                    wartością będzie edytowane w trakcie działania programu -
                    <b>let</b>.
                </li>
            </ul>
            <p class="article__text">
                Inicjalizacja zmiennej to nadanie jej wartości. Możliwa jest inicjalizacja zmiennej podczas
                deklaracji. Jeśli w czasie deklaracji żadna wartość nie zostanie przypisana do zmiennej, automatycznie
                przyjmie ona wartość <strong>undefined</strong>.
            </p>
        </article>
        <article id="arrays" class="article">
            <h2 class="article__heading">tablice</h2>
            <p class="article__text">Tablica (array):</p>
            <ul class="article__list">
                <li class="article__list-item">
                    Jest niejednorodną strukturą danych, ponieważ może przechowywać
                    różne typy danych jednocześnie (np. liczby, łańcuchy znaków,
                    obiekty).
                </li>
                <li class="article__list-item">
                    Aby zadeklarować tablicę, należy użyć nawiasów kwadratowych.
                    Elementy tablicy można zdefiniować już podczas deklaracji tablicy
                    (poprzez umieszczenie ich wewnątrz nawiasów kwadratowych i
                    oddzielenie od siebie przecinkiem) lub dodać je później (z
                    wykorzystaniem odpowiednich metod).
                </li>
                <li class="article__list-item">
                    Każdy z elementów tablicy posiada indeks, czyli swoją pozycję w
                    tablicy. Pierwszy element tablicy ma indeks 0. Aby odwołać się do
                    elementu o danym indeksie, należy podać indeks w nawiasach
                    kwadratowych po nazwie zmiennej, do której przypisana jest tablica.
                </li>
            </ul>
            <p class="article__text">Wybrane własności i funkcje tablic:</p>
            <ul class="article__list">
                <li class="article__list-item">
                    <b>length</b> Zwraca ilość elementów tablicy.
                </li>
                <li class="article__list-item">
                    <b>push(element)</b> Dodaje <b>element</b> na koniec tablicy.
                </li>
                <li class="article__list-item">
                    <b>pop()</b> Usuwa element z końca tablicy.
                </li>
                <li class="article__list-item">
                    <b>unshift(element)</b> Dodaje <b>element</b> na początek tablicy.
                </li>
                <li class="article__list-item">
                    <b>shift()</b> Usuwa element z początku tablicy.
                </li>
                <li class="article__list-item">
                    <b>indexOf(element)</b> Zwraca indeks pierwszego napotkanego
                    <b>element</b> lub wartość -1, gdy <b>element</b> nie zostanie
                    odnaleziony w tablicy.
                </li>
                <li class="article__list-item">
                    <b>splice(index, amount)</b> Rozpoczynając od elementu o indeksie
                    <b>index</b>, usuwa <b>amount</b> elementów z tablicy.
                </li>
                <li class="article__list-item">
                    <b>slice(startIndex, endIndex)</b> Rozpoczynając od elementu o
                    indeksie <b>startIndex</b> (włącznie), pobiera elementy z tablicy
                    kończąc na elemencie o indeksie <b>endIndex</b> (z wyłączeniem tego
                    elementu).
                </li>
            </ul>
        </article>
        <article id="loops" class="article">
            <h2 class="article__heading">pętle</h2>
            <p class="article__text">
                Pętla (loop) wykonuje blok kodu określoną liczbę razy.
            </p>
            <p class="article__text">Rodzaje pętli:</p>
            <ul class="article__list">
                <li class="article__list-item">
                    <b>for(let</b> <u>i=0</u><b>;</b> <u>i&lt;10</u><b>;</b> <u>i++</u><b>) {</b>blockOfCode<b>}</b>
                </li>
                <li class="article__list-item">
                    <b>while(</b><u>i&lt;10</u><b>) {</b>blockOfCode<b>}</b>
                </li>
                <li class="article__list-item">
                    <b>do {</b>blockOfCode<b>} while(</b><u>i&lt;10</u><b>)</b>
                </li>
                <li class="article__list-item">
                    <b>for(let</b> <u>propertyName</u> <b>in</b> <u>object</u><b>)</b>
                </li>
                <li class="article__list-item">
                    <b>for(let</b> <u>element</u> <b>of</b> <u>array</u><b>)</b>
                </li>
            </ul>
            <p class="article__text">
                Pętla <b>for</b> składa się z inicjalizacji <u>iteratora</u>,
                <u>warunku</u> oraz <u>wyrażenia inkrementacji/dekrementacji</u>. Blok
                kodu wewnątrz pętli zostanie wykonany, jeśli warunek zwróci wartość
                prawdziwą.
            </p>
            <p class="article__text">
                Pętla <b>while</b> zawiera <u>warunek</u>. Blok kodu wewnątrz pętli
                zostanie wykonany, jeśli warunek zwróci wartość prawdziwą. Pętla
                najpierw sprawdza warunek, a później wykonuje blok kodu, zatem jeśli
                początkowy warunek zwróci wartość fałszywą, pętla nie wykona się ani
                razu.
            </p>
            <p class="article__text">
                Pętla <b>do ... while</b> zawiera <u>warunek</u>. Blok kodu wewnątrz
                pętli zostanie wykonany, jeśli warunek zwróci wartość prawdziwą. Pętla
                najpierw wykonuje blok kodu, a później sprawdza warunek, zatem jeśli
                początkowy warunek zwróci wartość fałszywą, pętla wykona się raz.
            </p>
            <p class="article__text">
                Pętla <b>for ... in</b> składa się z inicjalizacji
                <u>zmiennej określającej własność obiektu</u>
                oraz odwołania do <u>obiektu</u>. Iteruje się po wszystkich
                własnościach przekazanego obiektu.
            </p>
            <p class="article__text">
                Pętla <b>for ... of</b> składa się z inicjalizacji
                <u>zmiennej określającej element tablicy</u>
                oraz odwołania do <u>tablicy</u>. Iteruje się po wszystkich elementach
                tablicy.
            </p>
            <p class="article__text">Rodzaje inkrementacji i dekrementacji:</p>
            <ul class="article__list">
                <li class="article__list-item">
                    <b>preinkrementacja (++i)</b> Zwiększa wartość wyrażenia o 1 przed
                    wykonaniem pozostałych operacji.
                </li>
                <li class="article__list-item">
                    <b>predekrementacja (--i)</b> Zmniejsza wartość wyrażenia o 1 przed
                    wykonaniem pozostałych operacji.
                </li>
                <li class="article__list-item">
                    <b>postinkrementacja (i++)</b> Zwiększa wartość wyrażenia o 1 po
                    wykonaniu pozostałych operacji.
                </li>
                <li class="article__list-item">
                    <b>postdekrementacja (i--)</b> Zmniejsza wartość wyrażenia o 1 po
                    wykonaniu pozostałych operacji.
                </li>
            </ul>
        </article>
        <article id="conditional-statements" class="article">
            <h2 class="article__heading">instrukcje warunkowe</h2>
            <p class="article__text">Instrukcje warunkowe:</p>
            <ul class="article__list">
                <li class="article__list-item">
                    <b>if(condition)</b> Kod w klamrach następujących po instrukcji 'if'
                    wykona się jeśli warunek w nawiasie zwróci prawdę.
                </li>
                <li class="article__list-item">
                    <b>else if(condition)</b> Kod w klamrach następujących po instrukcji
                    'if else' wykona się jeśli warunek w nawiasie zwróci prawdę oraz
                    jeśli żaden z wcześniejszych warunków instrukcji nie zwrócił prawdy.
                </li>
                <li class="article__list-item">
                    <b>else</b> Kod w klamrach następujących po instrukcji 'else' wykona
                    się jeśli żaden z wcześniejszych warunków instrukcji nie zwrócił
                    prawdy.
                </li>
            </ul>
            <ul class="article__list">
                <li class="article__list-item">
                    <b>switch(variable)</b> Wykona kod dla przypadku odpowiadającego
                    wartości zmiennej znajdującej się w nawiasie. W przypadku braku
                    takiego przypadku zwróci wartość domyślną, która jest zdefiniowana
                    na końcu instrukcji. Instrukcja przy porównaniu sprawdza również
                    zgodność typów.
                </li>
            </ul>
            <ul class="article__list">
                <li class="article__list-item">
                    <b> (condition) ? 'ifTrue' : 'ifFalse' </b> 'Ternary operator'.
                    Jeśli warunek podany przed znakiem zapytania jest spełniony,
                    zwracana jest wartość znajdująca się między znakiem zapytania a
                    dwukropkiem. W przeciwnym razie zwracana jest wartość znajdująca się
                    po dwukropku.
                </li>
            </ul>
        </article>
        <article id="data-types" class="article">
            <h2 class="article__heading">typy danych</h2>
            <p class="article__text">Typy proste w JavaScript:</p>
            <ul class="article__list">
                <li class="article__list-item">
                    <b>String</b> Tekst. Należy podać go w apostrofach (zalecany
                    pojedynczy).
                </li>
                <li class="article__list-item"><b>Number</b> Liczba.</li>
                <li class="article__list-item">
                    <b>Bigint</b> Duża liczba. Większa niż 2^53.
                </li>
                <li class="article__list-item"><b>boolean</b> True lub false.</li>
                <li class="article__list-item">
                    <b>null</b> Wartość celowo niezdefiniowana. Na etapie deklaracji
                    jeszcze nie wiadomo jaką wartość przyjmie, ale wiadomo że zmienna
                    będzie wykorzystana w trakcie działania programu. Przez niektóre źródła zaliczany jako typ złożony
                    (operator 'typeof' zwraca dla 'null' wartość 'object' ze względu na to, że JS jest
                    kompatybilny wstecz i zmiana tego mogłaby spowodować nieprawidłowe działanie istniejących
                    programów).
                </li>
                <li class="article__list-item">
                    <b>undefined</b> Brak definicji. Przy próbie odwołania do
                    nieistniejącej zmiennej występuje błąd.
                </li>
                <li class="article__list-item">
                    <b>*symbol</b> Tworzy "unikalne opakowanie".
                </li>
            </ul>
            <p class="article__text">Typy złożone w JavaScript:</p>
            <ul class="article__list">
                <li class="article__list-item">
                    <b>Object</b> Służy do przechowywania bardziej złożonych informacji niż te, które można przedstawić
                    za pomocą typów prostych.
                </li>
            </ul>
            <p class="article__text">
                Do nazywania zmiennych należy używać schematu camelCase.<br />
                Do sprawdzenia typu zmiennej służy słowo kluczowe <b>typeof</b>.<br />
                Operator przypisania '=' nie tworzy nowych zmiennych, lecz tworzy i
                zwraca połączenie.<br />
                W przypadku połączenia zmiennej 'a' ze zmienną 'b', występuje
                połączenie z wartością zmiennej 'b' a nie bezpośrednio z samą zmienną
                'b'.<br />
                Wywoływanie metod na typach prostych jest możliwe, ponieważ przed wykonaniem metody dokonuje się
                zamiana wartości prostej na obiekt (konwersja niejawna), a po wykonaniu metody dokonuje się taka sama
                zamiana w przeciwnym kierunku.
            </p>
        </article>
        <article id="functions" class="article">
            <h2 class="article__heading">funkcje</h2>
            <p class="article__text">Składowe funkcji w JavaScript:</p>
            <ul class="article__list">
                <li class="article__list-item">Deklaracja.</li>
                <li class="article__list-item">Parametr (opcjonalnie). Podczas wywołania funkcji określany mianem
                    argumentu.
                </li>
                <li class="article__list-item">
                    Słowo kluczowe <b>return</b> (opcjonalnie).
                </li>
                <li class="article__list-item">Wynik (jeśli po słowie kluczowym <b>return</b> nie będzie wyniku do
                    zwrócenia - funkcja zwróci wartość <b>undefined</b>).</li>
            </ul>
            <p class="article__text">Sposoby deklaracji funkcji:</p>
            <ul class="article__list">
                <li class="article__list-item">Funkcja nazwana (możliwe jest jej napisanie poprzez nadanie takiej samej
                    nazwy innej funkcji):<br />
                    <b>function functionName (parameter) {functionBody}</b>.
                </li>
                <li class="article__list-item">Funkcja anonimowa (przypisana do zmiennej zadeklarowanej z wykorzystaniem
                    <b>const</b> lub <b>let</b>, nie może zostać ponownie przypisana do takiej samej nazwy):<br />
                    <b>const name = function (parameter) {functionBody};</b>.
                </li>
                <li class="article__list-item">Funkcja strzałkowa:<br />
                    <b>const functionName = (parameter) => {functionBody};</b>.
                </li>
            </ul>
            <p class="article__text">
                Wynikiem funkcji, która nie posiada słowa kluczowego jest
                <b>undefined</b>.<br />
                Funkcja może przyjmować dowolną ilość argumentów (może również nie
                przyjmować żadnego).<br />
                Typ zwracanej wartości może być inny niż typ argumentu/argumentów
                przyjmowanych przez funkcję.<br />
                Funkcje tworzone są w celu wywoływania tego samego fragmentu kodu w
                wielu miejscach. Pozwala to uniknąć duplikacji kodu, zwiększa jego
                czytelność oraz ułatwia wyszukiwanie i poprawę błędów.<br />
                Dobrą praktyką jest nazywanie funkcji podczas deklaracji.<br />
                Wewnątrz funkcji wykowywane są obliczenia/zadania.<br />
            </p>
            <p class="article__text">Własności funkcji strzałkowej</p>
            <ul class="article__list">
                <li class="article__list-item">Jeśli w ciele funkcji znajduje się tylko <b>return</b> oraz zwracana
                    wartość, można zapisać tę wartość bezpośrednio po strzałce z pominięciem słowa kluczowego
                    <b>return</b> oraz nawiasów klamrowych.
                </li>
                <li class="article__list-item">Jeśli funkcja przyjmuje tylko jeden parametr, można pominąć nawiasy
                    okrągłe w
                    których jest on zawarty (w przypadku większej ilości parametrów lub ich braku nawiasy są wymagane).
                </li>
                <li class="article__list-item">Nawiasy okrągłe umożliwiają napisanie zwracanej wartości w kolejnej linii
                    (jeśli nie użyto nawiasów klamrowych).</li>
                <li class="article__list-item">Funkcja strzałkowa skraca zapis deklaracji funkcji i zwiększa czytelność.
                </li>
                <li class="article__list-item">Funkcja strzałkowa nie tworzy nowego kontekstu 'this' oraz nie ma dostępu
                    do 'arguments' i 'super', a więc nie jest zamiennikiem tradycyjnej funkcji.</li>
            </ul>
        </article>
        <article id="object-orientation" class="article">
            <h2 class="article__heading">obiektowość</h2>
            <p class="article__text">Nawiasy klamrowe tworzą izolowany blok kodu. Zmienne i funkcje zadeklarowane
                w bloku są dostępne tylko w nim (a także w zakresach niższego poziomu zagnieżdżonych w tym bloku).</p>
            <p class="article__text">Obiekt w JavaScript:</p>
            <ul class="article__list">
                <li class="article__list-item">
                    Jest strukturą danych ułatwiającą odwzorowanie świata rzeczywistego
                    w świecie programowania.
                </li>
                <li class="article__list-item">
                    Aby go zadeklarować, należy użyć nawiasów klamrowych.
                </li>
                </li>
                <li class="article__list-item">
                    Posiada oddzielone przecinkami własności (zmienne wewnątrz obiektu)
                    oraz metody (funkcje wewnątrz obiektu).
                </li>
                <li class="article__list-item">
                    Własności/metody składają się z unikalnego w ramach obiektu klucza
                    oraz podanej po dwukropku wartości, którą może być typ prymitywny,
                    funkcja lub zagnieżdżenie.
                </li>
                <li class="article__list-item">
                    Aby dostać się do konkretnej własności obiektu, należy po jego
                    nazwie i kropce odwołać się do konkretnego klucza (w przypadku kiedy
                    w obiekcie występują zagnieżdżenia, można dostać się do kolejnych
                    poziomów własności z wykorzystaniem kolejnych kropek).
                </li>
                <li class="article__list-item">
                    Aby dostać się do konkretnej metody obiektu, należy po jego nazwie i
                    kropce odwołać się do konkretnego klucza oraz użyć nawiasów
                    okrągłych (i opcjonalnie argumentów) w celu wywołania metody. W przypadku braku użycia nawiasów
                    okrągłych wyświetlona zostanie informacja, że obiekt posiada funkcję pod tą nazwą.
                </li>
                <li class="article__list-item">
                    Alternatywną opcją dostania się do własności obiektu jest
                    skorzystanie z nawiasów kwadratowych po jego nazwie i podanie
                    wewnątrz nich konkretnego klucza (w apostrofach). Sposób wykorzystywany głównie w przypadku klucza
                    zdefiniowanego w apostrofach (np. wielowyrazowy klucz zawierający spacje).
                </li>
                <li class="article__list-item">
                    Własności/metody obiektu można edytować. Wystarczy dostać się do nich z wykorzystaniem klucza, użyć
                    operatora przypisania
                    oraz podać nową wartość (odwołanie z użyciem nieistniejącego klucza spowoduje dodanie obiektowi
                    nowej własności/metody).
                </li>
                <li class="article__list-item">Kiedy podczas tworzenia obiektu nadawana jest mu własność, której wartość
                    pochodzi ze zmiennej, a klucz tej wartości ma taką samą
                    nazwę jak ta zmienna - wystarczy wpisać sam klucz w obiekcie i pominąć dwukropek oraz wartość.
                    Zostanie
                    ona przypisana automatycznie ze zmiennej.</li>
                <li class="article__list-item">
                    Na własnościach obiektu możliwe jest wykonywanie metod.
                </li>
            </ul>
            <p class="article__text">Mutowanie obiektów:</p>
            <ul class="article__list">
                <li class="article__list-item">Kontekst 'this' powstaje w momencie wywołania metody. W przypadku funkcji
                    strzałkowej jest pobierany z zewnętrznego zakresu (z zakresu wyższego poziomu), natomiast w
                    przypadku
                    innej funkcji kontekst ten jest tworzony (odnosi się do obiektu, na którym wywołano metodę).</li>
                <li class="article__list-item">Jeśli obiekt został stworzony z użyciem słowa kluczowego const, jedynie
                    połączenie między nazwą zmiennej a obiektem jest stałe i nie może zostać zmienione. Połączenia
                    między własnościami obiektu i wartościami na jakie wskazują mogą być jednak w dalszym ciągu
                    edytowane. Jest to tzw. mutowanie obiektów, czyli ich zmienianie. Cecha ta odróżnia typy złożone
                    (obiekty) od typów prostych, które nie mogą być mutowane.</li>
                <li class="article__list-item">Jeśli wskazujemy na wartości proste, klucz będzie odwoływał się do danej
                    wartości, dopóki nie zmienimy dokładnie tego przypięcia.</li>
                <li class="article__list-item">Jeśli wskazujemy na obiekt, może on zostać zmieniony, kiedy zmienione
                    zostanie przypięcie dla którejś z jego własności. Zmiana takiego przypięcia może nastąpić z
                    "inicjatywy" innego elementu wskazującego na ten obiekt.</li>
            </ul>
            <p class="article__text">Konstruktory:</p>
            <ul class="article__list">
                <li class="article__list-item">To szablony służące do tworzenia nowych, podobnych obiektów.</li>
                <li class="article__list-item">Jest to funkcja pozwalająca na tworzenie nowych obiektów (dla odróżnienia
                    od standardowej funkcji, jej nazwę należy pisać wielką literą).</li>
                <li class="article__list-item">Musi być to funkcja nazwana, ponieważ funkcja strzałkowa posiada kontekst
                    'this' wyższego poziomu.</li>
                <li class="article__list-item">Konstruktory należy wywoływać z użyciem słowa kluczowego 'new', które
                    tworzy nowy obiekt, dzięki czemu kontekst 'this' dotyczy tego utworzonego obiektu, zamiast zakresu
                    wyższego poziomu.</li>
                <li class="article__list-item">Obiekt utworzony za pomocą konstruktora należy przypisać do zmiennej. W
                    przeciwnym razie zostanie stworzony, lecz natychmiast zniknie ze względu na brak możliwości
                    odwołania się do niego.</li>
            </ul>
        </article>
        <article id="ecmascript-6" class="article">
            <h2 class="article__heading">ecmascript 6</h2>
            <p class="article__text">ECMAScript 6 to specyfikacja/standard JavaScript wprowadzony w 2015 roku.</p>
            <p class="article__text">Najistotniejsze zmiany wprowadzone wraz z ES 6:</p>
            <ul class="article__list">
                <li class="article__list-item"><b>Parametry domyślne funkcji</b> - parametry, które zostaną użyte
                    automatycznie jako argument w czasie wywołania funkcji, jeżeli jako argument zostanie przekazana
                    wartość 'undefined' (lub jeśli nie zostanie przekazany żaden argument). Jeżeli argument inny niż
                    'undefined' zostanie przekazany podczas wywołania funkcji, parametr domyślny nie zostanie użyty.
                    Wartości parametrów domyślnych należy podać podczas deklaracji funkcji z użyciem operatora
                    przypisania. Parametry domyślne należy definiować jako ostatnie w funkcji, ponieważ jeśli podczas
                    wywołania funkcji zostanie przekazana mniejsza liczba argumentów niż liczba zdefiniowanych
                    parametrów, to argumenty te będą przyporządkowywane do zdefiniowanych parametrów po kolei od lewej
                    strony.
                </li>
                <li class="article__list-item"><b>Destrukturyzacja w tablicach</b> - pozwala na przypisanie do zmiennych
                    początkowych elementów tablicy (z wykorzystaniem dodatkowych przecinków pomiędzy elementami można
                    także przypisać elementy inne niż
                    początkowe, jednak nie jest to zalecane ze względu na brak czytelności): <b>const
                        [element0ConstName,
                        element1ConstName] = arrayName;</b>.
                </li>
                <li class="article__list-item"><b>Destrukturyzacja w obiektach</b> - pozwala na przypisanie do zmiennych
                    własności/metod obiektów (jeśli po dwukropku nie zostaną podane nazwy zmiennych, będą one takie same
                    jak klucze danej własności/metody w obiekcie): <b>const {propertyKey, methodKey:
                        methodConstName} =
                        objectName;</b>.
                </li>
                <li class="article__list-item"><b>Spread operator</b> - pozwala na pobranie wszystkich elementów
                    tablicy/własności i metod obiektu. Najczęściej wykorzystywany do tworzenia kopii tablicy/obiektu
                    przez przypisanie go do innej zmiennej. W celu użycia operatora należy poprzedzić trzema kropkami
                    nazwę
                    tablicy/obiektu:
                    <b>...arrayName</b>.
                </li>
                <li class="article__list-item"><b>Rest operator</b> - pozwala na przyjęcie przez funkcję nieograniczonej
                    liczby argumentów (przed operatorem mogą zostać przekazane także inne argumenty). Argumenty
                    przekazane z użyciem operatora są przekazywane do funkcji w formie tablicy. W celu użycia
                    operatora należy przy deklaracji funkcji podać jako ostatni parametr nazwę tablicy poprzedzoną
                    trzema kropkami: <b>const functionName = (optionalParameter, ...arrayName) =>
                        {functionBody};</b>.</li>
                <li class="article__list-item"><b>String templates</b> - pozwala na używanie wewnątrz Stringa wyrażeń
                    JavaScript, tabulatorów oraz enterów. String taki musi zawierać się wewnątrz grawisów (`). Nie
                    zadziała w przypadku apostrofów (') i cudzysłowów ("). Wyrażenia JavaScript wewnątrz takiego Stringa
                    należy przekazać wewnątrz nawiasów klamrowych poprzedzonych znakiem dolara: <b>`Text ${JavaScript
                        expression} text.`</b>.</li>
            </ul>
        </article>
        <article id="classes" class="article">
            <h2 class="article__heading">klasy</h2>
            <p class="article__text">Klasy są elementem programowania zorientowanego obiektowo i podobnie jak
                konstrutrory
                są szablonami służącymi do tworzenia obiektów. </p>
            <p class="article__text">Właściwości klas:</p>
            <ul class="article__list">
                <li class="article__list-item">Typem klasy jest <b>function</b>, ponieważ operator <b>typeof</b> odnosi
                    się on do jej konstruktora.</li>
                <li class="article__list-item">W momencie wywołania klasy, tak naprawdę wywoływana
                    jest metoda <b>constructor</b>. Dzieje się tak nawet w przypadku braku zdefiniowania tej metody w
                    klasie, ponieważ wtedy pusty konstruktor zostanie zdefiniowany domyślnie (wywołanie go nie wymaga
                    podania jego nazwy przed nawiasami). Zdefiniowanie tej metody w klasie pozwala na utworzenie
                    własnego konstruktora.</li>
                <li class="article__list-item">Wywołanie metody <b>constructor</b> zdefiniowanej w klasie działa
                    analogicznie jak (używana głównie przed wprowadzeniem standardu ES 6) funkcja konstruktora. Oba te
                    sposoby tworzą kopię danej własności/metody dla każdego utworzonego obiektu (co jest mniej wydajne i
                    zajmuje dodatkowe miejsce w pamięci RAM).<br />
                    Metoda <b>constructor</b> zdefiniowana w klasie: <b>class ClassName {constructor() {}}</b>.<br />
                    Funkcja konstruktora: <b>function ConstructorFunctionName() {}</b>.
                </li>
                <li class="article__list-item">Zdefiniowanie metody obiektu bezpośrednio w klasie (poza konstruktorem)
                    działa analogicznie jak zdefiniowanie jej z wykorzystaniem (używanego głównie przed wprowadzeniem
                    standardu ES 6) <b>prototype</b>. Oba te sposoby podczas utworzenia nowego obiektu tworzą
                    odniesienie do danej metody, zamiast kopiować ją dla każdego utworzonego obiektu (co jest
                    bardziej wydajne i nie zajmuje dodatkowego miejsca w pamięci RAM).<br />
                    Metoda zdefiniowana bezpośrednio w klasie: <b>class ClassName {methodName() {methodBody}}</b>.<br />
                    Metoda zdefiniowana z wykorzystaniem <b>prototype</b>:
                    <b>ConstructorFunctionName.prototype.methodName = function() {methodBody}</b>.
                </li>
            </ul>
        </article>
        <article id="advanced-arrays" class="article">
            <h2 class="article__heading">zaawansowane metody tablicowe</h2>
            <p class="article__text">Metody ułatwiające wykonywanie operacji na tablicach:</p>
            <ul class="article__list">
                <li class="article__list-item"><b>forEach()</b> - jako argument przyjmuje funkcję, która z kolei może
                    przyjmować trzy parametry (ich nazwa może być dowolna, natomiast kolejność ma znaczenie): element,
                    indeks, oryginalna tablica. Metoda nie tworzy nowej tablicy, lecz jedynie przechodzi przez każdy jej
                    element.
                </li>
                <li class="article__list-item"><b>map()</b> - jako argument przyjmuje funkcję, która z kolei może
                    przyjmować trzy parametry (ich nazwa może być dowolna, natomiast kolejność ma znaczenie): element,
                    indeks, oryginalna tablica. Metoda tworzy nową tablicę z taką samą ilością elementów jak oryginalna
                    tablica. Funkcja będąca argumentem metody przechodzi przez wszystkie elementy oryginalnej tablicy i
                    w każdej iteracji zwraca wartość, która trafia do nowej tablicy z takim samym indeksem.
                </li>
                <li class="article__list-item"><b>filter()</b> - jako argument przyjmuje funkcję, która z kolei może
                    przyjmować trzy parametry (ich nazwa może być dowolna, natomiast kolejność ma znaczenie): element,
                    indeks, oryginalna tablica. Metoda tworzy nową tablicę. Funkcja będąca argumentem metody przechodzi
                    przez wszystkie elementy oryginalnej tablicy i w każdej iteracji zwraca wartość <b>true</b> (wtedy
                    element znajdujący się pod tym indeksem jest dodawany do nowej tablicy) w lub <b>false</b> (wtedy
                    element znajdujący się pod tym indeksem nie jest dodawany do nowej tablicy).
                </li>
            </ul>
        </article>
        <article id="asynchrony" class="article">
            <h2 class="article__heading">asynchroniczność</h2>
            <p class="article__text">Asynchroniczność to brak oczekiwania na zakończenie jednego zadania, podczas gdy
                wykonuje się inne zadanie. Różni się od wielowątkowości pewnego rodzaju bezwładnością. Możemy reagować
                na zakończenie danego zadania, ale nie mamy pełnej kontroli nad tym jak zadanie jest wykonywane w
                środku (jak na przykład w języku C++).</p>
            <p class="article__text">W JavaScript bardzo wiele API jest asynchronicznych, tzn. odbieranie danych polega
                na reagowaniu np. na callback. Nawet podstawowy javascript zawiera asynchroniczne funkcje/metody.
                Najprostszym przykładem są funkcje: <b>setTimeout()</b> i <b>setInterval()</b>:</p>
            <ul class="article__list">
                <li class="article__list-item"><b>setTimeout()</b> - wykonuje funkcję przekazaną jako argument
                    (<b>callback</b>) z określonym opóźnieniem. W związku z tym, że <b>setTimeout()</b> jest funkcją
                    asynchroniczną, kod znajdujący się po niej nie będzie czekał na zakończenie działania tej funkcji.
                </li>
                <li class="article__list-item"><b>setInterval()</b> - wykonuje funkcję przekazaną jako argument
                    (<b>callback</b>) wielokrotnie z określonym interwałem. W związku z tym, że <b>setInterval()</b>
                    jest
                    funkcją asynchroniczną, kod znajdujący się po niej nie będzie czekał na zakończenie działania tej
                    funkcji.</li>
            </ul>
            <p class="article__text">JavaScript jest jednak językiem jednowątkowym. Jeśli powyższe funkcje zostaną
                wywołane z mniejszym opóźnieniem niż wynosi czas wykonania wyrażeń następujących po nich - funkcja
                wykona się dopiero po zakończeniu wykonywania takich wyrażeń (kiedy będzie możliwe wejście w wątek).</p>
            <p class="article__text">Większość aktualnie powstających API JavaScriptu opiera się w jakimś stopniu na
                asynchroniczności. Nie blokuje to głównego wątku, np. strony internetowej podczas wykonywania zapytań do
                sieci lub do serwera, kiedy obsługuje on zapytania/żądania.</p>
            <p class="article__text">Node.js czerpie jeszcze bardziej z asynchroniczności. Wprowadza tzw. <b>Async
                    I/O</b> dzięki bibliotece <b>libuv</b>. Pozwala ona na brak blokowania podczas m.in.: operacji
                sieciowych, operacji na plikach, operacji na bazach danych. Jest to bardzo ważne od strony biznesowej,
                ponieważ pozwala to w praktyce bardzo łatwo obsługiwać wiele operacji jednocześnie.</p>
            <p class="article__text">Sposoby obsługi asynchroniczności w JavaScript:</p>
            <ul class="article__list">
                <li class="article__list-item"><b>Callback</b> - przekazywanie jako argumentu funkcji, która zostanie
                    uruchomiona pod pewnym warunkiem (np. po upływie określonego czasu). Minusem tego rozwiązania jest
                    tzw. <b>callback hell</b> - zbyt rozbudowana struktura zagnieżdżeń funkcji.</li>
                <li class="article__list-item"><b>Promises</b> - warstwa abstrakcji na zadania asynchroniczne w
                    JavaScript. W tym przypadku potencjalnym problemem może być tzw. <b>promise hell</b> - zbyt
                    rozbudowana struktura zagnieżdżeń zwracanych obiektów typu <b>Promise</b>. Można go jednak uniknąć
                    wywołując kolejne funkcje <b>then()</b> bezpośrednio po sobie oraz funkcję <b>catch()</b> na końcu
                    (zostanie ona wywołana w przypadku niezwrócenia obiektu <b>Promise</b> przez którąś z wcześniejszych
                    funkcji). Użycie <b>Promise</b> można rozważać z dwóch stron: jako <b>wykonawca</b> lub jako
                    <b>oczekujący na wynik</b>. <b>Promise</b> może znajdować się w jednym z trzech stanów:
                    <b>pending</b> (oczekujący), <b>fulfilled</b> (spełniony), <b>rejected</b> (odrzucony).
                </li>
                <li class="article__list-item"><b>Async/await</b> - słowa kluczowe pozwalające na obsługę
                    asynchroniczności. Metoda ta charakteryzuje się wysoką czytelnością kodu (jest on niemal identyczny
                    jak synchroniczny) a także dużą jego przepustowością (główny wątek nie jest blokowany, kiedy nie
                    jest to konieczne). Współpracuje z obiektami typu <b>Promise</b>. Słowo kluczowe <b>async</b>,
                    poprzedzające deklarację funkcji, oznacza ją jako asynchroniczną oraz tworzy ukryty obiekt
                    <b>Promise</b>. Natomiast <b>await</b> wskazuje w którym miejscu należy oczekiwać na rezultat i
                    zwolnić wątek dla innych operacji. Funkcja typu <b>async</b> może sama się wywoływać, wystarczy jej
                    deklarację umieścić w nawiasach, a po niej użyć dwóch kolejnych oznaczających wywołanie.
                </li>
            </ul>
            <p class="article__text">Wbudowana funkcja przeglądarkowa pozwalająca na wysłanie żądania w celu otrzymania
                informacji zwrotnej to <b>fetch()</b>. Wywołanie tej funkcji tworzy asynchroniczną obietnicę, której
                rozwiązaniem będzie informacja zwrotna z serwera. Funkcja <b>fetch()</b> przyjmuje jako argument adres
                URL, pod który zostanie wysłane żądanie, natomiast zwraca obiekt typu <b>Promise</b>, na którym można
                wywołać m.in. metody: <b>then()</b> (która jako argument może przyjąć odpowiedź na <b>Promise</b>, a jej
                <b>callback</b> wykona się w przypadku spełnienia obietnicy), <b>catch()</b> (która jako argument może
                przyjąć błąd, a jej <b>callback</b> wykona się w przypadku niespełnienia obietnicy). Odpowiedź zwracana
                przez obiekt <b>Promise</b> musi zostać rozkodowana poprzez wywołanie na niej metody <b>json()</b>,
                która zwraca kolejny obiekt <b>Promise</b> (zawierający właściwe dane) ze względu na to, że
                rozkodowanie danych również może zajmować czas, który przeglądarka mogłaby poświęcić na wykonywanie
                innych czynności. Zarówno metodę <b>then()</b> jak i <b>catch()</b> można wywołać bezpośrednio po sobie
                na jednym obiekcie (w większości przypadków zostanie wykonana jedynie jedna z nich, w zależności od tego
                czy obietnica została spełniona).
            </p>
            <p class="article__text">Funkcje asynchroniczne <b>setTimeout()</b> i <b>setInterval()</b> domyślnie
                opierały się na sposobie z wykorzystaniem <b>callback</b>, jednak Node od wersji 16 umożliwia ich użycie
                z wykorzystaniem <b>Promise</b>. Należy skorzystać z modułu <b>'timers/promisies'</b>, importując go za
                pomocą funkcji <b>require()</b>.
            </p>
            <p class="article__text">
                Aby uruchomić kilka metod asynchronicznych i kontynuować działanie programu dopiero wtedy, kiedy
                wykonywanie ostatniej z nich dobiegnie końca (czyli gdy każda z nich zwróci obiekt typu <b>Promise</b>),
                należy skorzystać z metody <b>Promise.all()</b>. Jest to metoda statyczna (nie wywoływana na konkretnym
                obiekcie), która jako argument przyjmuje tablicę obiektów typu <b>Promise</b> (zwracanych przez te
                asynchroniczne metody), natomiast zwraca jeden wspólny obiekt tego samego typu, kiedy wszystkie obiekty
                przekazane jako argument zostaną zwrócone. Użycie słowa kluczowego <b>await</b> przed takim wspólnym
                obiektem, pozwala na uruchomienie grupy metod w sposób asynchroniczny.
            </p>
        </article>
        <article id="dom" class="article">
            <h2 class="article__heading">dom</h2>
            <p class="article__text">
                HTML zmieniany jest przez przeglądarkę w reprezentację zwaną <b>Document Object Model</b> (Model
                obiektowy dokumentu) - <b>DOM</b>.
            </p>
            <p class="article__text"><b>DOM</b> to zbiór obiektów (węzłów) tworzonych przede wszystkim przez znaczniki,
                atrybuty i zawartość tekstową. <b>DOM</b> ustawia wężły w strukturze typu drzewo, co tworzy między nimi
                relacje i zagnieżdżenia.
            </p>
            <p class="article__text">Elementy <b>DOM</b> mogą posiadać:</p>
            <ul class="article__list">
                <li class="article__list-item">rodzica;</li>
                <li class="article__list-item">rodzeństwo;</li>
                <li class="article__list-item">dzieci.</li>
            </ul>
            <p class="article__text">API przeglądarki pozwala poruszać się po drzewie <b>DOM</b> używając tych nazw.</p>
            <p class="article__text">Skrypty powinny być dodawane do pliku HTML na końcu znacznika <b>body</b>, ponieważ
                operują one na elementach <b>DOM</b>, które są generowane w momencie otwarcia znacznika. Dlatego ważne
                jest, aby po znacznikach dodających skrypty do strony nie było już żadnych innych znaczników
                otwierających.
            </p>
            <p class="article__text">Sposoby na pobranie konkretnego elementu DOM (które mogą zostać zapisane do
                zmiennej):
            </p>
            <ul class="article__list">
                <li class="article__list-item">Zaznaczenie go w zakładce <b>Elements</b> w narzędziach deweloperskich
                    przeglądarki a następnie odwołanie się do niego w zakładce <b>Console</b> za pomocą <b>$0</b>.</li>
                <li class="article__list-item">Odwołanie się poprzez element <b>document</b> (dotyczy jedynie niewielu
                    elementów strony, np. <b>document.head</b>, <b>document.body</b>, <b>document.links</b>).</li>
                <li class="article__list-item">Użycie metody <b>querySelector()</b> na obiekcie <b>document</b> z
                    parametrem odnoszącym się do ID (<b>'#idName'</b>), klasy (<b>'.className'</b>) bądź znacznika
                    (<b>'tagName'</b>). Selektory w JavaScript muszą być typu <b>string</b>. Zalecane jest pobieranie
                    elementów odwołując się do nazw klas, ponieważ w łatwy sposób pozwala na pobranie konkretnego
                    elementu.
                </li>
            </ul>
            <p class="article__text">Metoda służąca do nasłuchiwania w JavaScript to <b>addEventListener()</b>, która
                wywoływana jest na konkretnym elemencie <b>DOM</b> i przyjmuje jako argumenty: <b>typ zdarzenia jakiego
                    nasłuchuje</b> (jako <b>string</b>) oraz <b>nazwę wywoływanej funkcji</b>. Opcjonalnie metoda
                <b>addEventListener()</b> może przyjąć również inne argumenty. Wywoływaną funkcją może być również
                funkcja strzałkowa, przyjmująca jako argument dowolną nazwę. W takim przypadku nazwa ta będzie
                odnosić się do <b>eventu</b>.
            </p>
        </article>
        <article id="local-storage" class="article">
            <h2 class="article__heading">local storage</h2>
            <p class="article__text"><b>Local storage</b> to jeden z prostszych sposobów zapisywania na urządzeniu
                lokalnym (m.in. w przeglądarce) pewnych informacji tekstowych. Wyglądają one jak zmienne typu
                <b>string</b>. Każda informacja posiada nazwę i wartość tekstową. Dane są przechowywane do momentu
                ręcznego wyczyszczenia.
            </p>
            <p class="article__text">Zalety:</p>
            <ul class="article__list">
                <li class="article__list-item">Szybkie przechowanie informacji na czyimś komputerze.</li>
                <li class="article__list-item">Niewymagana zgoda właściciela urządzenia (stan na 07.2021).</li>
                <li class="article__list-item">Prostota obsługi.</li>
            </ul>
            <p class="article__text">Wady:</p>
            <ul class="article__list">
                <li class="article__list-item">Ograniczona wielkość przechowywanych danych.</li>
                <li class="article__list-item">Możliwość przechowywania jedynie danych tekstowych (przechowywania innych
                    typów danych wymaga używania różnych metod).</li>
                <li class="article__list-item">Synchroniczność.</li>
                <li class="article__list-item">Działanie lokalne na urządzeniu klienta (nie na serwerze).</li>
            </ul>
            <p class="article__text">Operacje na <b>localStorage</b>:</p>
            <ul class="article__list">
                <li class="article__list-item">Możliwości interakcji z zawartością local storage na stronie: zakładka
                    <b>Application</b> w narzędziach deweloperskich lub polecenie <b>localStorage</b> w konsoli.
                </li>
                <li class="article__list-item">Dodawanie nowego przechowywanego elementu:
                    <b>localStorage.setItem('</b>key<b>', '</b>value<b>')</b>.
                </li>
                <li class="article__list-item">Pobieranie przechowywanego elementu (w przypadku podania
                    nieistniejącego klucza, zwrócona zostanie wartość <b>null</b>):
                    <b>localStorage.getItem('</b>key<b>')</b>.
                </li>
                <li class="article__list-item">Usuwanie przechowywanego elementu:
                    <b>localStorage.removeItem('</b>key<b>')</b>.
                </li>

            </ul>
        </article>
        <article id="json" class="article">
            <h2 class="article__heading">json</h2>
            <p class="article__text"><b>JSON (JavaScript Object Notation)</b> - lekki, tekstowy format wymiany danych
                między różnymi programami, API itd. Pozwala przechowywać liczby, tekst, wartości typu boolean, null,
                tablice i obiekty w formie tekstowej. Aplikacja służąca do przeglądania, edycji i formatowania danych
                typu JSON to <a class="article__link" href="https://jsoneditoronline.org">JSON Editor Online</a>.</p>
            <ul class="article__list">
                <li class="article__list-item">W celu dodania obiektu do local storage, należy go najpierw
                    przekształcić na JSONString z wykorzystaniem metody: <b>JSON.stringify(</b>object<b>)</b>.</li>
                <li class="article__list-item">W celu pobrania z local storage obiektu przechowywanego
                    jako JSONString, należy go najpierw przekształcić na obiekt z wykorzystaniem metody:
                    <b>JSON.parse(</b>JSONString<b>)</b>.
                </li>
            </ul>
            <p class="article__text">Podczas pracy na serwerze lub na przeglądarce klienta zazwyczaj korzysta się z
                obiektów. Format JSON wykorzystywany jest głównie w celu przesyłania danych i może zostać odkodowany
                niezależnie od języka programowania.</p>
        </article>
    </main>
    <footer class="footer">
        <p class="footer__text">
            Zawartość będzie aktualizowana na bieżąco.
            <a class="footer__link" href="#top">Wróć na górę</a>
        </p>
        <p class="footer__text">Maciej Ryszka - 2021</p>
    </footer>
    <script src="../script.js"></script>
</body>

</html>